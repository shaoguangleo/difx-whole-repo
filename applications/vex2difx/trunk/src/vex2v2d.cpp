/***************************************************************************
 *   Copyright (C) 2021 by Walter Brisken                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/*===========================================================================
 * SVN properties (DO NOT CHANGE)
 *
 * $Id: $
 * $HeadURL: $
 * $LastChangedRevision: $
 * $Author: $
 * $LastChangedDate: $
 *
 *==========================================================================*/

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <limits.h>
#include <vexdatamodel.h>
#include <vex_utility.h>
#include "testvex.h"

const char program[] = "vex2v2d";
const char version[] = "0.1";
const char verdate[] = "20210113";
const char author[] = "Walter Brisken";

void usage(const char *pgm)
{
	fprintf(stderr, "\n%s ver. %s  %s  %s\n\n", program, version, author, verdate);
}

const char *getDatastreamMachine(const std::string &ant)
{
	if(ant == "BR") 
	{
		return "swc001";
	}
	else if(ant == "FD")
	{
		return "swc002";
	}
	else if(ant == "GB")
	{
		return "swc011";
	}
	else if(ant == "HN")
	{
		return "swc003";
	}
	else if(ant == "KP")
	{
		return "swc004";
	}
	else if(ant == "LA")
	{
		return "swc005";
	}
	else if(ant == "MK")
	{
		return "swc006";
	}
	else if(ant == "NL")
	{
		return "swc007";
	}
	else if(ant == "OV")
	{
		return "swc008";
	}
	else if(ant == "PT")
	{
		return "swc009";
	}
	else if(ant == "SC")
	{
		return "swc010";
	}
	else
	{
		return "swc020";
	}
}

int write_v2d(const VexData *V, const char *vexFile, const char *outFile, bool force, bool doPolar, double tInt, double specRes, bool doMachines, bool doSplit, bool doFilelist)
{
	FILE *out;
	unsigned int nAntenna = V->nAntenna();
	unsigned int nSource = V->nSource();
	bool doDatastreams = false;
	std::string lexper = V->getExper()->name;
	Lower(lexper);

	if(doSplit || doFilelist)
	{
		doDatastreams = true;
	}

	if(outFile == 0)	// assume stdout
	{
		out = stdout;
	}
	else
	{
		out = fopen(outFile, "w");
	}
	if(!out)
	{
		return EXIT_FAILURE;
	}

	fprintf(out, "# base .v2d file generated by %s version %s on file %s\n\n", program, version, vexFile);
	fprintf(out, "vex = %s\n\n", vexFile);
	fprintf(out, "antennas =");
	for(unsigned int a = 0; a < nAntenna; ++a)
	{
		const VexAntenna *A = V->getAntenna(a);
		if(a == 0)
		{
			fprintf(out, " %s", A->name.c_str());
		}
		else
		{
			fprintf(out, ", %s", A->name.c_str());
		}
	}
	fprintf(out, "\n\n");
	if(doMachines)
	{
		fprintf(out, "machines = swc000, swc011, swc012, swc013, swc014, swc015, swc016, swc017, swc018, swc019, swc020\n");
		fprintf(out, "nCore = 10\n");
		fprintf(out, "nThread = 4\n\n");
	}
	fprintf(out, "delayModel = difxcalc\n\n");

	for(unsigned int s = 0; s < nSource; ++s)
	{
		const VexSource *S = V->getSource(s);

		fprintf(out, "SOURCE %s { }\n", S->defName.c_str());
	}
	fprintf(out, "\n");

	for(unsigned int a = 0; a < nAntenna; ++a)
	{
		const VexAntenna *A = V->getAntenna(a);
		std::string lname = A->name;
		Lower(lname);

		if(doDatastreams)
		{
			if(a > 0)
			{
				fprintf(out, "\n");
			}
			fprintf(out, "DATASTREAM %s0 {", A->name.c_str());
			if(doSplit)
			{
				fprintf(out, " format=VDIF1032");
			}
			if(doFilelist)
			{
				fprintf(out, " filelist=%s.%s.filelist", lexper.c_str(), lname.c_str());
			}
			fprintf(out, " }\n");
		}

		fprintf(out, "ANTENNA %s { toneSelection=smart", A->name.c_str());
		if(doMachines)
		{
			const char *machine;

			machine = getDatastreamMachine(A->name);
			if(machine == 0)
			{
				fprintf(stderr, "Error: Machine mode was used for unsupported antenna: %s\n", A->name.c_str());

				exit(EXIT_FAILURE);
			}
			fprintf(out, " machine=%s", machine);
			if(doDatastreams)
			{
				fprintf(out, " datastreams=%s0", A->name.c_str());
			}
		}
	
		fprintf(out, " }\n");
	}
	fprintf(out, "\n");

	fprintf(out, "SETUP default\n");
	fprintf(out, "{\n");
	fprintf(out, "  tInt = %f\n", tInt);
	fprintf(out, "  fftSpecRes = %f\n", specRes);
	fprintf(out, "  specRes = %f\n", specRes);
	fprintf(out, "  doPolar = %s\n", (doPolar ? "True" : "False") );
	fprintf(out, "  numBufferedFFTs = 10\n");
	fprintf(out, "  maxNSBetweenACAvg = 2000000\n");
	fprintf(out, "}\n");

	if(out != stdout)
	{
		fclose(out);
	}

	return EXIT_SUCCESS;
}

int main(int argc, char **argv)
{
	VexData *V;
	int a;
	int v;
	unsigned int nWarn = 0;
	const char *vexFile = 0;
	char outFile[PATH_MAX];
	char *ext;
	int verbose = 0;
	double tInt = 0.0;
	double specRes = 0.0;
	bool force = false;
	bool doPolar = true;
	bool doMachines = false;
	bool doSplit = false;
	bool doFilelist = false;

	for(a = 1; a < argc; ++a)
	{
		if(strcmp(argv[a], "-h") == 0 ||
		   strcmp(argv[a], "--help") == 0)
		{
			usage(argv[0]);

			return EXIT_SUCCESS;
		}
		else if(strcmp(argv[a], "-v") == 0 ||
		        strcmp(argv[a], "--verbose") == 0)
		{
			++verbose;
		}
		else if(strcmp(argv[a], "-n") == 0 ||
		        strcmp(argv[a], "--nopolar") == 0)
		{
			doPolar = false;
		}
		else if(strcmp(argv[a], "-p") == 0 ||
		        strcmp(argv[a], "--polar") == 0)
		{
			doPolar = true;
		}
		else if(strcmp(argv[a], "-m") == 0 ||
		        strcmp(argv[a], "--machines") == 0)
		{
			doMachines = true;
		}
		else if(strcmp(argv[a], "-s") == 0 ||
		        strcmp(argv[a], "--split") == 0)
		{
			doSplit = true;
		}
		else if(strcmp(argv[a], "-F") == 0 ||
		        strcmp(argv[a], "--file") == 0)
		{
			doFilelist = true;
		}
		else if(strcmp(argv[a], "-f") == 0 ||
		        strcmp(argv[a], "--force") == 0)
		{
			force = true;
		}
		else if(argv[a][0] == '-')
		{
			printf("Unknown option %s .  Run with -h for help.\n\n", argv[a]);

			return EXIT_FAILURE;
		}
		else if(specRes > 0.0)
		{
			printf("Error: too many non-optional parameters provided.\n\n");

			return EXIT_FAILURE;
		}
		else if(vexFile == 0)
		{
			vexFile = argv[a];
		}
		else if(tInt <= 0.0)
		{
			tInt = atof(argv[a]);
		}
		else
		{
			specRes = atof(argv[a]);
		}
	}

	if(vexFile == 0)
	{
		printf("No file name provided.  Run with -h for help.\n\n");

		return EXIT_FAILURE;
	}
	strcpy(outFile, vexFile);
	ext = strstr(outFile, ".vex");
	if(!ext)
	{
		fprintf(stderr, "Error: the input filename should contain '.vex'\n");

		return EXIT_FAILURE;
	}
	strcpy(ext, ".v2d");

	if(tInt <= 0.0)
	{
		tInt = 2.0;

		fprintf(stderr, "Setting tInt to default value of %f\n", tInt);
	}

	if(specRes <= 0.0)
	{
		specRes = 0.25;

		fprintf(stderr, "Setting specRes to default value of %f\n", specRes);
	}

	v = testVex(vexFile);
	if(v != 0)
	{
		fprintf(stderr, "Cannot parse vex file.  Error code = %d\n", v);

		return EXIT_FAILURE;
	}

	V = loadVexFile(std::string(vexFile), &nWarn);

	if(verbose)
	{
		std::cout << *V << std::endl;
		std::cout << std::endl;
	}

	v = write_v2d(V, vexFile, outFile, force, doPolar, tInt, specRes, doMachines, doSplit, doFilelist);

	if(v == EXIT_SUCCESS)
	{
		fprintf(stderr, "\nOutput written to %s\n\n", outFile);
	}
	else
	{
		fprintf(stderr, "\nAn error occurred.\n\n");
	}

	delete(V);

	return v;
}
