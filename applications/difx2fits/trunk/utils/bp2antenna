#!/bin/env python3.8

from sys import argv, exit
from math import log, exp, sin, cos, sqrt, atan2
import numpy as np

def SolvePhaseClosure(M, W, R):
	dim = len(M)
	Ek = np.zeros(dim)
	for k in range(dim):
		for j in range(dim):
			Ek[k] += 4.0*W[j][k]*W[j][k]*M[j][k]

	Ekl = np.zeros([dim, dim])
	for k in range(dim):
		for l in range(dim):
			Ekl[k][l] = 4.0*W[k][l]*W[k][l]
		for j in range(dim):
			Ekl[k][k] -= 4.0*W[k][j]*W[k][j]

	# constrain reference value to be zero
	Ek[R] = 0.0
	for j in range(dim):
		Ekl[j][R] = 0.0
		Ekl[R][j] = 0.0
	Ekl[R][R] = 1.0

	EklInv = np.linalg.inv(Ekl)

	return np.matmul(EklInv, Ek)

def SolveAmpClosure(M, W):
	dim = len(M)
	Ek = np.zeros(dim)
	for k in range(dim):
		for j in range(dim):
			if M[j][k] > 0:
				Ek[k] += 4.0*W[j][k]*W[j][k]*log(M[j][k])

	Ekl = np.zeros([dim, dim])
	for k in range(dim):
		for l in range(dim):
			Ekl[k][l] = 4.0*W[k][l]*W[k][l]
		for j in range(dim):
			Ekl[k][k] += 4.0*W[k][j]*W[k][j]

	EklInv = np.linalg.inv(Ekl)

	x = np.matmul(EklInv, Ek)
	for k in range(dim):
		x[k] = exp(x[k])

	return x

# return [record], nAnt, bbcs
# record = [a1, a2, bbc, freq, bw, pol, freq[], amp[], phase[]
def loadBP(filename):
	data = open(filename).readlines()
	nAnt = 0
	bbcs = []
	records = []
	
	index = -1
	size = 0
	lineno = 0

	for d in data:
		lineno += 1
		line =  d.strip().split('#')[0]
		s = line.split()
		if len(s) == 0:
			continue
		elif len(s) == 8 and s[0] == 'Bandpass':
			a1 = int(s[1])
			a2 = int(s[2])
			bbc = int(s[3])
			size = int(s[4])
			index = 0
			freq = np.zeros(size)
			amp = np.zeros(size)
			phase = np.zeros(size)
			record = [ a1, a2, bbc, float(s[5]), float(s[6]), s[7], freq, amp, phase ]
			records.append(record)
			if nAnt < a1+1:
				nAnt = a1+1
			if nAnt < a2+1:
				nAnt = a2+1
			if not bbc in bbcs:
				bbcs.append(bbc)
		elif len(s) == 3:
			if index < 0 or index >= size:
				print('Weird: line %d unexpected (index = %d size = %d): %s' % (lineno, index, size, line))
				exit(0)
			freq[index] = float(s[0])
			re = float(s[1])
			im = float(s[2])
			amp[index] = sqrt(re*re + im*im)
			phase[index] = atan2(im, re)
			index += 1
		else:
			print('Weird: line %d unexpected: %s' % (lineno, line))
			
	return records, nAnt, bbcs

def process(records, nAnt, bbc, refant):
	size = 0

	freq = 0.0
	bw = 0.0
	pol = ' '

	for rec in records:
		if rec[2] == bbc:
			if size == 0:
				size = len(rec[6])
				freq = rec[3]
				bw = rec[4]
				pol = rec[5]
				freqs = rec[6]
			elif size != len(rec[6]):
				print('Size mismatch: bbc=%d %d!=%d' % (bbc, size, len(rec[6])))
				exit(0)

	a = []
	p = []
	
	for s in range(size):
		W = np.zeros([nAnt, nAnt])
		A = np.zeros([nAnt, nAnt])
		P = np.zeros([nAnt, nAnt])
		for rec in records:
			if rec[2] != bbc:
				continue
			a1 = rec[0]
			a2 = rec[1]
			W[a1][a2] += 1.0
			W[a2][a1] += 1.0
			A[a1][a2] += rec[7][s]
			A[a2][a1] += rec[7][s]
			P[a1][a2] -= rec[8][s]
			P[a2][a1] += rec[8][s]
		a.append(SolveAmpClosure(A, W))
		p.append(SolvePhaseClosure(P, W, refant))

	for ant in range(nAnt):
		print('Bandpass %d %d %d %f %f %s' % (ant, bbc, size, freq, bw, pol))
		for s in range(size):
			re = a[s][ant]*cos(p[s][ant])
			im = a[s][ant]*sin(p[s][ant])
			print('%f %f %f' % (freqs[s], re, im))


records, nAnt, bbcs = loadBP(argv[1])
refant = int(argv[2])

for bbc in bbcs:
	process(records, nAnt, bbc, refant)
